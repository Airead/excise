Introduction to Algorithms Second Edition
* 第二章
** 2.1 插入排序
*** 2.1-2 
    重写过程 INSERTION-SORT，使之按非升序（而不是按非降序）排序。
    file:excise/2.1-2.txt
*** 2.1-3 
    考虑下面的查找总题：
    输入：一列数 A = <a1,a2,...,an>和一个值v
    输出：下标i，使得v=A[i],或者当v不在A中出现时为NIL。
    写出针对这个问题的线性查找的伪代码，它顺序地扫描整个序列以查找v。利用循环不变式证明算法的正确性。确保所给出的循环不变式满足三个必要的性质。
    file:excise/2.1-3.txt
*** 2.1-4
    有两个各存放在数组A和B中的n位二进制整数，考虑它们相加的问题。两个整数的和以二进制形式存放在具有(n+1)个元素的数组中。请给出这个问题的形式化描述，并写出伪代码。
    file:excise/2.1-4.txt
** 2.2 算法分析
*** 2.2-2 
    考虑对数组A中的n个数进行排序的问题：首先找出A中的最小元素，并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素，并将其与A[2]中的元素进行交换。对A中头n-1个元素继续这一过程。写出这个算法的伪代码，该算法称为选择排序 (selection sort)。对这个算法来说，循环不变式是什么？为什么它仅需要在头n-1个元素上运行，而不是在所有n个元素上运行？O形式说明最好、最坏运行时间。
    file:excise/2.2-2.txt
*** 2.2-3 
    再次考虑线性查找问题 (见练习2.1-3)。在平均情况下，需要检查输入序列中的多少个元素？假定待查找的元素是数组中任何一个元素的可能性是相等的。在最坏情况下又怎样呢？O形式说明最好、最坏运行时间。
    file:excise/2.2-3.txt
*** 2.2-4
    应如何修改任何一个算法，才能使之具有较好的最佳情况运行时间？
    修改一个算法，检查它的输入是否符合某个特殊的条件，如果符合，可以直接给出预先算好的答案。
** 2.3 算法设计
*** 2.3-2
    改写 MERGE 过程，使之不使用哨兵元素，而是在一旦数组L或R中的所有元素都被复制回数组A后，就立即停止，再将另一个数组中余下的元素复制回数组A中。
    file:excise/2.3-2.txt
*** 2.3-4
    插入排序可以如下改写成一个递归过程：为排序A[1..n]，先递归地排序A[1..n-1]，然后再将A[n]插入到已排序的数组A[1..n-1]中去。对于插入排序的这一递归版本，为它的运行时间写一个递归式。
    file:excise/2.3-4.txt
*** 2.3-5
    回顾一下练习2.1-3中提出的查找问题，注意如果序列A是已排序的，就可以将序列的中点与v进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找(binary search)就是一个不断重复这一查找过程的算法，它每次都将序列余下的部分分成两半，并只对其中的一半做进一步的查找。写出二分查找算法的伪代码，可以是迭代的，也可以是递归的。说明二分查找算法的最坏情况运行时间为什么O(lgn)。
    file:excise/2.3-5.txt
*** 2.3-6
    观察一下2.1节中给出的 INSERTION-SORT 过程，在第5～7行的 while 循环中，采用了一种线性查找策略，在已排序的数组A[1..j-1]中（反向）扫描。是否可以改用二分查找策略（（见练习2.3-5），来将插入排序的总休最坏情况运行时间改善至O(nlgn)
    file:excise/2.3-6.txt
*** 2.3-7
    请给出一个运行时间为O(nlgn)的算法，使之能在给定一个由n个整数构成的集合S和另一个整数x时，判断出S中是否存在有两个其和等于x的元素。
    file:excise/2.3-7.txt
   
