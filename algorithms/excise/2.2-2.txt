P: 考虑对数组A中的n个数进行排序的问题：首先找出A中的最小元素，并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素，并将其与A[2]中的元素进行交换。对A中头n-1个元素继续这一过程。写出这个算法的伪代码，该算法称为选择排序 (selection sort)。对这个算法来说，循环不变式是什么？为什么它仅需要在头n-1个元素上运行，而不是在所有n个元素上运行？O形式说明最好、最坏运行时间。

假定A[0]这个不存在的元素是最小的元素。
SELECTION_SORT(A)
for j <- 1 to n-1
    do key <- A[j];
       for i <- j+1 to n
           if key < A[i]
              then key <- A[i]
       交换 key 与 A[j] 的值

第一轮循环开始前，A[0]是已经是A[1...n]中最小的元素。
每一轮循环开始前，A[1..j-1]已经是A[1..n]中前j-1个从小到大排好序的数组
循环结束时，j = n,那么A[1..n-1]是A中前n-1个从小到大排好序的数组，那么A中最后一个元素一定是最大的。


SELECTION_SORT(A)
for j <- 1 to n-1                  n
    do key <- A[j];                n-1
       for i <- j+1 to n           n+(n-1)+(n-2)+...+1
           if key < A[i]           (n-1)+(n-2)+...+1
              then key <- A[i]     ((n-1)+(n-2)+...+1)/2
       交换 key 与 A[j] 的值         n-1

最坏的情况: O(n^2)
最好的情况: O(n^2)
